<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Benchmark - Token Throughput per GPU vs E2E Latency</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #fff;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #1a1a1a;
        }
        .subtitle {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 0.85rem;
            font-weight: 500;
            color: #333;
        }
        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            background: #fff;
            cursor: pointer;
            min-width: 200px;
        }
        select:hover {
            border-color: #999;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 700px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
        }
        .legend-container {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #333;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .legend-line {
            width: 20px;
            height: 2px;
            border-radius: 1px;
        }
        .legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #000;
            margin-left: -13px;
            margin-right: 0px;
        }
        .info-box {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #555;
        }
        .info-box h3 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: #333;
        }
        .info-box ul {
            margin-left: 20px;
        }
        .info-box li {
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <h1>Token Throughput per GPU vs End-to-end Latency</h1>
    <p class="subtitle">vLLM Benchmark • 8 GPUs • C100 P100 O128</p>
    
    <div class="controls">
        <div class="control-group">
            <label for="gpuSelect">GPU Type</label>
            <select id="gpuSelect">
                <option value="all">All GPUs</option>
                <option value="b200">B200 (RunPod)</option>
                <option value="h200">H200 SXM (RunPod)</option>
                <option value="h100">H100 SXM (RunPod)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="modelSelect">Model</label>
            <select id="modelSelect">
                <option value="all">All Models</option>
                <option value="gpt-oss-120b">GPT-OSS-120B</option>
                <option value="qwen3-32b">Qwen3-32B</option>
                <option value="glm-4.7">GLM-4.7 (358B)</option>
                <option value="glm-4.7-fp8">GLM-4.7-FP8</option>
            </select>
        </div>
        <div class="control-group">
            <label for="configSelect">Parallelism (TP/DP)</label>
            <select id="configSelect">
                <option value="all">All Configs</option>
                <option value="TP8/DP1">TP8 / DP1</option>
                <option value="TP4/DP2">TP4 / DP2</option>
            </select>
        </div>
    </div>
    
    <div class="chart-container">
        <canvas id="benchmarkChart"></canvas>
    </div>
    
    <div class="legend-container" id="legendContainer"></div>
    
    <div class="info-box">
        <h3>Benchmark Configuration</h3>
        <ul>
            <li><strong>Parallelism:</strong> TP8/DP1 or TP4/DP2 (Total: 8 GPUs)</li>
            <li><strong>Concurrency:</strong> 100 requests</li>
            <li><strong>Input Length:</strong> Variable (1024, 2048, 4096, 8192, 15000 tokens)</li>
            <li><strong>Output Length:</strong> 128 tokens</li>
            <li><strong>Throughput per GPU:</strong> Total Token Throughput / 8</li>
        </ul>
    </div>

    <script>
        // Register the datalabels plugin
        Chart.register(ChartDataLabels);

        // Benchmark data - generated by process_benchmarks.py
        const benchmarkData = {
            "b200_glm-4.7_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 1620, e2eLatency: 8.71, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 3219, e2eLatency: 8.27, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 4267, e2eLatency: 12.02, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 5006, e2eLatency: 20.04, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 5683, e2eLatency: 31.99, config: "TP8/DP1" }
            ],
            "b200_glm-4.7-fp8_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 1654, e2eLatency: 8.51, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 3101, e2eLatency: 8.57, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 4169, e2eLatency: 12.28, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 4939, e2eLatency: 20.25, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 5640, e2eLatency: 32.12, config: "TP8/DP1" }
            ],
            "b200_qwen3-32b_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 5839, e2eLatency: 2.26, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 9848, e2eLatency: 2.72, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 13957, e2eLatency: 3.71, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 15544, e2eLatency: 6.51, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 14878, e2eLatency: 12.39, config: "TP4/DP2" }
            ],
            "b200_qwen3-32b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 6039, e2eLatency: 2.34, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 10977, e2eLatency: 2.43, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 13230, e2eLatency: 3.89, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 14755, e2eLatency: 6.84, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 15830, e2eLatency: 11.54, config: "TP8/DP1" }
            ],
            "b200_gpt-oss-120b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 5135, e2eLatency: 2.75, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 9969, e2eLatency: 2.66, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 14326, e2eLatency: 3.56, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 18261, e2eLatency: 5.46, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 22036, e2eLatency: 8.19, config: "TP8/DP1" }
            ],
            "h100_glm-4.7-fp8_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 1379, e2eLatency: 10.31, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 2182, e2eLatency: 12.3, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 2614, e2eLatency: 19.82, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 2272, e2eLatency: 36.8, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 2119, e2eLatency: 62.47, config: "TP4/DP2" }
            ],
            "h100_glm-4.7-fp8_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 1354, e2eLatency: 10.44, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 2493, e2eLatency: 10.71, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 3158, e2eLatency: 16.33, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 2363, e2eLatency: 34.59, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 1932, e2eLatency: 71.78, config: "TP8/DP1" }
            ],
            "h100_qwen3-32b_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 3760, e2eLatency: 3.52, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 6364, e2eLatency: 4.2, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 7729, e2eLatency: 6.71, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 7693, e2eLatency: 13.15, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 7684, e2eLatency: 24.06, config: "TP4/DP2" }
            ],
            "h100_qwen3-32b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 4174, e2eLatency: 3.4, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 7522, e2eLatency: 3.56, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 8628, e2eLatency: 6.0, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 9013, e2eLatency: 11.27, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 9218, e2eLatency: 19.95, config: "TP8/DP1" }
            ],
            "h100_gpt-oss-120b_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 4022, e2eLatency: 3.54, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 7149, e2eLatency: 3.74, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 9840, e2eLatency: 5.25, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 12300, e2eLatency: 8.24, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 14135, e2eLatency: 13.01, config: "TP4/DP2" }
            ],
            "h100_gpt-oss-120b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 3809, e2eLatency: 3.7, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 8344, e2eLatency: 3.18, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 11653, e2eLatency: 4.39, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 14554, e2eLatency: 6.87, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 17243, e2eLatency: 10.47, config: "TP8/DP1" }
            ],
            "h200_glm-4.7-fp8_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 1512, e2eLatency: 9.42, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 2306, e2eLatency: 11.62, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 2834, e2eLatency: 18.26, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 3487, e2eLatency: 29.24, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 2841, e2eLatency: 62.9, config: "TP4/DP2" }
            ],
            "h200_glm-4.7-fp8_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 1482, e2eLatency: 9.54, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 2764, e2eLatency: 9.66, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 3488, e2eLatency: 14.77, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 3887, e2eLatency: 25.99, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 4208, e2eLatency: 43.52, config: "TP8/DP1" }
            ],
            "h200_qwen3-32b_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 4687, e2eLatency: 3.02, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 6637, e2eLatency: 4.05, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 8821, e2eLatency: 5.88, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 8175, e2eLatency: 12.38, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 8092, e2eLatency: 22.54, config: "TP4/DP2" }
            ],
            "h200_qwen3-32b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 4408, e2eLatency: 3.22, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 8086, e2eLatency: 3.31, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 9186, e2eLatency: 5.64, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 9445, e2eLatency: 10.78, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 9518, e2eLatency: 19.38, config: "TP8/DP1" }
            ],
            "h200_gpt-oss-120b_TP4/DP2": [
                { ctx: 1024, throughputPerGpu: 4330, e2eLatency: 3.29, config: "TP4/DP2" },
                { ctx: 2048, throughputPerGpu: 7740, e2eLatency: 3.46, config: "TP4/DP2" },
                { ctx: 4096, throughputPerGpu: 11235, e2eLatency: 4.6, config: "TP4/DP2" },
                { ctx: 8192, throughputPerGpu: 13115, e2eLatency: 7.71, config: "TP4/DP2" },
                { ctx: 15000, throughputPerGpu: 14365, e2eLatency: 12.78, config: "TP4/DP2" }
            ],
            "h200_gpt-oss-120b_TP8/DP1": [
                { ctx: 1024, throughputPerGpu: 4114, e2eLatency: 3.43, config: "TP8/DP1" },
                { ctx: 2048, throughputPerGpu: 8981, e2eLatency: 2.95, config: "TP8/DP1" },
                { ctx: 4096, throughputPerGpu: 12553, e2eLatency: 4.07, config: "TP8/DP1" },
                { ctx: 8192, throughputPerGpu: 15755, e2eLatency: 6.33, config: "TP8/DP1" },
                { ctx: 15000, throughputPerGpu: 18640, e2eLatency: 9.69, config: "TP8/DP1" }
            ]
        };

        // Color scheme: Same color per model
        const modelColors = {
            'gpt-oss-120b': '#f97316',  // Orange
            'qwen3-32b': '#22c55e',      // Green
            'glm-4.7': '#0891b2',        // Cyan
            'glm-4.7-fp8': '#8b5cf6'     // Purple
        };

        // Display labels for combinations
        function getLabel(gpu, model, config) {
            const gpuNames = {
                'b200': 'B200',
                'h100': 'H100',
                'h200': 'H200'
            };
            const modelNames = {
                'gpt-oss-120b': 'GPT-OSS-120B',
                'qwen3-32b': 'Qwen3-32B',
                'glm-4.7': 'GLM-4.7',
                'glm-4.7-fp8': 'GLM-4.7-FP8'
            };
            return `${gpuNames[gpu] || gpu} ${modelNames[model] || model}`;
        }

        function getColor(key) {
            // Extract model from key (format: gpu_model_config)
            const parts = key.split('_');
            const model = parts[1];
            return modelColors[model] || '#666666';
        }

        let chart;

        function getFilteredData(gpuFilter, modelFilter, configFilter) {
            const datasets = [];
            
            Object.keys(benchmarkData).forEach(key => {
                // Parse key: gpu_model_config (e.g., "b200_glm-4.7_TP8/DP1")
                const parts = key.split('_');
                const gpu = parts[0];
                const model = parts[1];
                const config = parts[2];
                
                // Apply filters
                if (gpuFilter !== 'all' && gpu !== gpuFilter) return;
                if (modelFilter !== 'all' && model !== modelFilter) return;
                if (configFilter !== 'all' && config !== configFilter) return;
                
                const data = benchmarkData[key].map(d => ({
                    x: d.e2eLatency,
                    y: d.throughputPerGpu,
                    ctx: d.ctx,
                    config: d.config
                }));
                
                // Sort by e2eLatency (x-axis) for proper line connection
                data.sort((a, b) => a.x - b.x);
                
                const color = getColor(key);
                const label = getLabel(gpu, model, config);
                
                datasets.push({
                    label: label,
                    data: data,
                    backgroundColor: '#000000',
                    borderColor: color,
                    pointRadius: 1.5,
                    pointHoverRadius: 3,
                    pointBorderColor: '#000000',
                    pointBorderWidth: 0,
                    showLine: true,
                    tension: 0,
                    borderWidth: 1
                });
            });
            
            return datasets;
        }

        function updateLegend(datasets) {
            const container = document.getElementById('legendContainer');
            container.innerHTML = datasets.map(ds => `
                <div class="legend-item">
                    <div class="legend-line" style="background: ${ds.borderColor};"></div>
                    <div class="legend-dot"></div>
                    <span>${ds.label}</span>
                </div>
            `).join('');
        }

        function createChart() {
            const ctx = document.getElementById('benchmarkChart').getContext('2d');
            const datasets = getFilteredData('all', 'all', 'all');
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        datalabels: {
                            display: function(context) {
                                return context.dataIndex === context.dataset.data.length - 1;
                            },
                            align: 'right',
                            anchor: 'end',
                            clip: false,
                            offset: function(context) {
                                const chart = context.chart;
                                const datasets = chart.data.datasets;
                                const endpoints = [];
                                
                                // Collect all endpoints with pixel positions
                                datasets.forEach((ds, idx) => {
                                    if (ds.data.length > 0) {
                                        const lastPoint = ds.data[ds.data.length - 1];
                                        const meta = chart.getDatasetMeta(idx);
                                        if (meta.data && meta.data.length > 0) {
                                            const pixel = meta.data[meta.data.length - 1];
                                            if (pixel) {
                                                endpoints.push({ 
                                                    idx, 
                                                    pixelX: pixel.x, 
                                                    pixelY: pixel.y,
                                                    dataY: lastPoint.y
                                                });
                                            }
                                        }
                                    }
                                });
                                
                                // Sort by pixelY (screen position, top to bottom)
                                endpoints.sort((a, b) => a.pixelY - b.pixelY);
                                
                                const currentIdx = context.datasetIndex;
                                const myPos = endpoints.findIndex(e => e.idx === currentIdx);
                                const myEndpoint = endpoints[myPos];
                                
                                if (!myEndpoint) return 4;
                                
                                // Count how many labels are very close above this one
                                let stackPosition = 0;
                                const labelHeight = 10; // approximate label height in pixels
                                
                                for (let i = 0; i < myPos; i++) {
                                    const other = endpoints[i];
                                    // If within 20 pixels vertically, they might overlap
                                    if (Math.abs(other.pixelY - myEndpoint.pixelY) < 20) {
                                        stackPosition++;
                                    }
                                }
                                
                                return 4;
                            },
                            font: {
                                size: 7,
                                weight: '400'
                            },
                            color: '#555',
                            padding: { left: 3 },
                            textAlign: 'left',
                            formatter: function(value, context) {
                                const fullLabel = context.dataset.label;
                                let label = fullLabel.replace('-120B', '').replace('-32B', '').replace('Qwen3-32B', 'Qwen3');
                                // Add config from the data point
                                const lastPoint = context.dataset.data[context.dataset.data.length - 1];
                                if (lastPoint && lastPoint.config) {
                                    const shortConfig = lastPoint.config.replace('/DP1', '').replace('TP', 'TP');
                                    label += ' ' + shortConfig;
                                }
                                return label;
                            },
                            // Use y offset to stack overlapping labels
                            y: function(context) {
                                const chart = context.chart;
                                const datasets = chart.data.datasets;
                                const endpoints = [];
                                
                                datasets.forEach((ds, idx) => {
                                    if (ds.data.length > 0) {
                                        const lastPoint = ds.data[ds.data.length - 1];
                                        const meta = chart.getDatasetMeta(idx);
                                        if (meta.data && meta.data.length > 0) {
                                            const pixel = meta.data[meta.data.length - 1];
                                            if (pixel) {
                                                endpoints.push({ 
                                                    idx, 
                                                    pixelY: pixel.y,
                                                    pixelX: pixel.x
                                                });
                                            }
                                        }
                                    }
                                });
                                
                                // Sort by Y position (top to bottom on screen)
                                endpoints.sort((a, b) => a.pixelY - b.pixelY);
                                
                                const currentIdx = context.datasetIndex;
                                const myPos = endpoints.findIndex(e => e.idx === currentIdx);
                                const myEndpoint = endpoints[myPos];
                                
                                if (!myEndpoint) return 0;
                                
                                // Stack labels that are close together vertically
                                // Use larger threshold and offset for better separation
                                let stackOffset = 0;
                                const labelHeight = 9; // pixels between stacked labels
                                const collisionThreshold = 25; // pixels to consider as collision
                                
                                for (let i = 0; i < myPos; i++) {
                                    const yDiff = Math.abs(endpoints[i].pixelY - myEndpoint.pixelY);
                                    if (yDiff < collisionThreshold) {
                                        stackOffset += labelHeight;
                                    }
                                }
                                
                                return stackOffset;
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255,255,255,0.95)',
                            titleColor: '#333',
                            bodyColor: '#666',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    return context[0].dataset.label;
                                },
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `Context: ${point.ctx} tokens`,
                                        `Parallelism: ${point.config}`,
                                        `Throughput/GPU: ${point.y.toLocaleString()} tok/s`,
                                        `E2E Latency: ${point.x.toFixed(2)}s`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'End-to-end Latency (s)',
                                font: { weight: '500' }
                            },
                            grid: { color: '#f0f0f0' },
                            min: 0,
                            max: 80
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Token Throughput per GPU (tok/s/gpu)',
                                font: { weight: '500' }
                            },
                            grid: { color: '#f0f0f0' },
                            min: 0,
                            max: 25000
                        }
                    }
                }
            });
            
            updateLegend(datasets);
        }

        function updateChart() {
            const gpuFilter = document.getElementById('gpuSelect').value;
            const modelFilter = document.getElementById('modelSelect').value;
            const configFilter = document.getElementById('configSelect').value;
            
            const datasets = getFilteredData(gpuFilter, modelFilter, configFilter);
            chart.data.datasets = datasets;
            chart.update();
            updateLegend(datasets);
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            createChart();
            
            document.getElementById('gpuSelect').addEventListener('change', updateChart);
            document.getElementById('modelSelect').addEventListener('change', updateChart);
            document.getElementById('configSelect').addEventListener('change', updateChart);
        });
    </script>
</body>
</html>
